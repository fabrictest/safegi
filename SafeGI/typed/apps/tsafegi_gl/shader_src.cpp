#include "shader_src.h"
#include <assert.h>

const char *typed_shadowmap_vs = 
"attribute point<shape_s>     local_point;\n"
"attribute normal<shape_s>    local_normal;\n"
"uniform rigidmap<shape_s, world_s> mXf;\n"
"uniform rigidmap<world_s, source_s> lXf;\n"
"uniform projmap<source_s, clip_s> lpXf;\n"
"void main()\n"
"{\n"
"point<shape_s> l_pos = local_point;\n"
"point<world_s> w_pos = transform(mXf, l_pos);\n"
"gl_Position = project(lpXf, transform(lXf, w_pos));\n"
"}\n";

const char *typed_shadowmap_fs = 
"void main()\n"
"{\n"
"gl_FragColor = alpha_spectrum<radiance_d>(0.0, 0.0, 0.0, 0.0);\n"
"}\n";

const char *typed_image_vs = 
"attribute point<shape_s>     local_point;\n"
"attribute normal<shape_s>    local_normal;\n"
"varying normal<world_s> norm;\n"
"varying point<world_s> position;\n"
"varying hpoint<clip_s> shadow_coord0;\n"
"varying hpoint<clip_s> shadow_coord1;\n"
"varying hpoint<clip_s> shadow_coord2;\n"
"varying hpoint<clip_s> shadow_coord3;\n"
"varying hpoint<clip_s> shadow_coord4;\n"
"varying hpoint<clip_s> shadow_coord5;\n"
"uniform rigidmap<shape_s, world_s> mXf;\n"
"uniform rigidmap<world_s, lens_s> vXf;\n"
"uniform projmap<lens_s, clip_s> pXf;\n"
"uniform rigidmap<world_s, source_s> lXf0;\n"
"uniform rigidmap<world_s, source_s> lXf1;\n"
"uniform rigidmap<world_s, source_s> lXf2;\n"
"uniform rigidmap<world_s, source_s> lXf3;\n"
"uniform rigidmap<world_s, source_s> lXf4;\n"
"uniform rigidmap<world_s, source_s> lXf5;\n"
"uniform projmap<source_s, clip_s> lpXf;\n"
"void main()\n"
"{\n"
"point<shape_s> s_pos = local_point;\n"
"point<world_s> w_pos = transform(mXf, s_pos);\n"
"point<lens_s> v_pos = transform(vXf, w_pos);\n"
"norm = transform(mXf, local_normal);\n"
"position = w_pos;\n"
"shadow_coord0 = project(lpXf, transform(lXf0, w_pos));\n"
"shadow_coord1 = project(lpXf, transform(lXf1, w_pos));\n"
"shadow_coord2 = project(lpXf, transform(lXf2, w_pos));\n"
"shadow_coord3 = project(lpXf, transform(lXf3, w_pos));\n"
"shadow_coord4 = project(lpXf, transform(lXf4, w_pos));\n"
"shadow_coord5 = project(lpXf, transform(lXf5, w_pos));\n"
"gl_Position = project(pXf, v_pos);\n"
"}\n";

const char *typed_pointlight_fs = 
"varying normal<world_s> norm;\n"
"varying point<world_s> position;\n"
"varying hpoint<clip_s> shadow_coord0;\n"
"varying hpoint<clip_s> shadow_coord1;\n"
"varying hpoint<clip_s> shadow_coord2;\n"
"varying hpoint<clip_s> shadow_coord3;\n"
"varying hpoint<clip_s> shadow_coord4;\n"
"varying hpoint<clip_s> shadow_coord5;\n"
"uniform point<world_s> light_pos;\n"
"uniform point<world_s> eye_pos;\n"
"uniform spectrum<intensity_d> intensity;\n"
"uniform spectrum<rho_d> rhod;\n"
"uniform spectrum<rho_d> rhos;\n"
"uniform real n;\n"
"uniform spectrum<radiance_d> em;\n"
"uniform real invsamples;\n"
"uniform sampler2D<mreal<length_d>> shadow_map0;\n"
"uniform sampler2D<mreal<length_d>> shadow_map1;\n"
"uniform sampler2D<mreal<length_d>> shadow_map2;\n"
"uniform sampler2D<mreal<length_d>> shadow_map3;\n"
"uniform sampler2D<mreal<length_d>> shadow_map4;\n"
"uniform sampler2D<mreal<length_d>> shadow_map5;\n"
"real shadow_test(sampler2D<mreal<length_d>> shadow_map, hpoint<clip_s> shadow_coord, real old_shadow)\n"
"{\n"
"real shadow = old_shadow;\n"
"mreal<length_d> epsilon = mreal<length_d>(0.01);\n"
"vector<clip_s> scoord = homogenize(shadow_coord) - point<clip_s>(-1.0,-1.0,-1.0);\n"
"if(scoord.x < 0.0)\n"
"return shadow;\n"
"if(scoord.x > 2.0)\n"
"return shadow;\n"
"if(scoord.y < 0.0)\n"
"return shadow;\n"
"if(scoord.y > 2.0)\n"
"return shadow;\n"
"if(shadow_coord.w > 0.0)\n"
"{\n"
"if(texture2D(shadow_map, tuple2(scoord.x * 0.5, scoord.y * 0.5)) < ((scoord.z * 0.5) - epsilon))\n"
"shadow = real(0.0);\n"
"}\n"
"return shadow;\n"
"}\n"
"void main ()\n"
"{\n"
"vector<world_s> lv = light_pos - position;\n"
"direction<world_s> L = normalize(lv);\n"
"normal<world_s> N = norm;\n"
"direction<world_s> V = normalize(eye_pos - position);\n"
"direction<world_s> R = reflect(-L, N);\n"
"mreal<invsolidangle_d> ss_pdf = mreal<invsolidangle_d>(1.0);\n"
"real shadow = 1.0;\n"
"shadow = shadow_test(shadow_map0, shadow_coord0, shadow);\n"
"shadow = shadow_test(shadow_map1, shadow_coord1, shadow);\n"
"shadow = shadow_test(shadow_map2, shadow_coord2, shadow);\n"
"shadow = shadow_test(shadow_map3, shadow_coord3, shadow);\n"
"shadow = shadow_test(shadow_map4, shadow_coord4, shadow);\n"
"shadow = shadow_test(shadow_map5, shadow_coord5, shadow);\n"
"spectrum<radiance_d> le = intensity / (lengthSqr(lv) * mreal<proj_d>(1.0));\n"
"mreal<projsolidangle_d> hemisphericalProjectedAngle = mreal<projsolidangle_d>(3.141592654);\n"
"spectrum<rho_d> spec;\n"
"if( n <= 0.0 )\n"
"{\n"
"spec = spectrum<rho_d>(0.0, 0.0, 0.0);\n"
"}\n"
"else\n"
"{\n"
"spec = rhos * ((n + 2.0) * pow(max(dot(V,R),0.0), n) / 2.0);\n"
"}\n"
"spectrum<brdf_d> brdf = (rhod + spec) / hemisphericalProjectedAngle;\n"
"spectrum<radiance_d> color = em + le * brdf * poscos(N, L) / (ss_pdf);\n"
"gl_FragColor =  attach_alpha(color * shadow * invsamples, 1.0);\n"
"}\n";


const char *typed_arealight_fs = 
"varying normal<world_s> norm;\n"
"varying point<world_s> position;\n"
"varying hpoint<clip_s> shadow_coord0;\n"
"varying hpoint<clip_s> shadow_coord1;\n"
"varying hpoint<clip_s> shadow_coord2;\n"
"varying hpoint<clip_s> shadow_coord3;\n"
"varying hpoint<clip_s> shadow_coord4;\n"
"varying hpoint<clip_s> shadow_coord5;\n"
"uniform point<world_s> light_pos;\n"
"uniform point<world_s> eye_pos;\n"
"uniform spectrum<intensity_d> intensity;\n"
"uniform spectrum<rho_d> rhod;\n"
"uniform spectrum<rho_d> rhos;\n"
"uniform real n;\n"
"uniform spectrum<radiance_d> em;\n"
"uniform spectrum<radiance_d> le;\n"
"uniform direction<world_s> ln;\n"
"uniform mreal<area_d> sa;\n"
"uniform real invsamples;\n"
"uniform sampler2D<mreal<length_d>> shadow_map0;\n"
"uniform sampler2D<mreal<length_d>> shadow_map1;\n"
"uniform sampler2D<mreal<length_d>> shadow_map2;\n"
"uniform sampler2D<mreal<length_d>> shadow_map3;\n"
"uniform sampler2D<mreal<length_d>> shadow_map4;\n"
"uniform sampler2D<mreal<length_d>> shadow_map5;\n"
"real shadow_test(sampler2D<mreal<length_d>> shadow_map, hpoint<clip_s> shadow_coord, real old_shadow)\n"
"{\n"
"real shadow = old_shadow;\n"
"vector<clip_s> scoord = homogenize(shadow_coord) - point<clip_s>(-1.0,-1.0,-1.0);\n"
"if(scoord.x < 0.0)\n"
"return shadow;\n"
"if(scoord.x > 2.0)\n"
"return shadow;\n"
"if(scoord.y < 0.0)\n"
"return shadow;\n"
"if(scoord.y > 2.0)\n"
"return shadow;\n"
"if(shadow_coord.w > 0.0)\n"
"{\n"
"mreal<length_d> epsilon = mreal<length_d>(0.01);\n"
"if(texture2D(shadow_map, tuple2(scoord.x * 0.5, scoord.y * 0.5)) < (scoord.z * 0.5 - epsilon))\n"
"shadow = real(0.0);\n"
"}\n"
"return shadow;\n"
"}\n"
"void main ()\n"
"{\n"
"vector<world_s> lv = light_pos - position;\n"
"direction<world_s> L = normalize(lv);\n"
"normal<world_s> N = norm;\n"
"direction<world_s> V = normalize(eye_pos - position);\n"
"direction<world_s> R = reflect(-L, N);\n"
"real shadow = 1.0;\n"
"shadow = shadow_test(shadow_map0, shadow_coord0, shadow);\n"
"shadow = shadow_test(shadow_map1, shadow_coord1, shadow);\n"
"shadow = shadow_test(shadow_map2, shadow_coord2, shadow);\n"
"shadow = shadow_test(shadow_map3, shadow_coord3, shadow);\n"
"shadow = shadow_test(shadow_map4, shadow_coord4, shadow);\n"
"shadow = shadow_test(shadow_map5, shadow_coord5, shadow);\n"
"if(cos(ln,-L) <= 0.0)\n"
"gl_FragColor = attach_alpha(em * shadow * invsamples, 1.0);\n"
"else\n"
"{\n"
"mreal<invsolidangle_d> ss_pdf = mreal<invsolidangle_d>(lengthSqr(lv) / (sa * cos(ln,-L)));\n"
"mreal<projsolidangle_d> hemisphericalProjectedAngle = mreal<projsolidangle_d>(3.141592654);\n"
"spectrum<rho_d> spec;\n"
"if( n <= 0.0 )\n"
"{\n"
"spec = spectrum<rho_d>(0.0, 0.0, 0.0);\n"
"}\n"
"else\n"
"{\n"
"spec = rhos * ((n + 2.0) * pow(max(dot(V,R),0.0), n) / 2.0);\n"
"}\n"
"spectrum<brdf_d> brdf = (rhod + spec) / hemisphericalProjectedAngle;\n"
"spectrum<radiance_d> color = em + le * brdf * poscos(N, L) / (ss_pdf);\n"
"gl_FragColor =  attach_alpha(color * shadow * invsamples, 1.0);\n"
"}\n"
"}\n";

const char *get_shader(shader_id id)
{
    switch(id)
    {
    case SHADOW_MAP_VS_SOURCE:
        return typed_shadowmap_vs;
    case SHADOW_MAP_FS_SOURCE:
        return typed_shadowmap_fs;
    case IMAGE_VS_SOURCE:
        return typed_image_vs;
    case POINTLIGHT_FS_SOURCE:
        return typed_pointlight_fs;
    case AREALIGHT_FS_SOURCE:
        return typed_arealight_fs;
    default:
        assert(false);
    }
    return 0;
}
